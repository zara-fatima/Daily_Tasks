// #include <iostream>
// #include <queue>
// #include <vector>
// #include <cmath>
// #include <climits>
// using namespace std;

// class Node {
// public:
//     int data;
//     Node *left, *right;
//     Node(int v) : data(v), left(nullptr), right(nullptr) {}
// };

// class BinaryTree {
//     Node* root;

// public:
//     BinaryTree() { root = nullptr; }
//     Node* getRoot() { return root; }

//     void insert(int v) {
//         Node* n = new Node(v);
//         if (!root) { root = n; cout << "Root created: " << v << endl; return; }
//         queue<Node*> q; q.push(root);
//         while (!q.empty()) {
//             Node* cur = q.front(); q.pop();
//             if (!cur->left) { cur->left = n; cout << "Inserted " << v << " to LEFT of " << cur->data << endl; return; }
//             else q.push(cur->left);
//             if (!cur->right) { cur->right = n; cout << "Inserted " << v << " to RIGHT of " << cur->data << endl; return; }
//             else q.push(cur->right);
//         }
//     }

//     void preorder(Node* n) { if (!n) return; cout << n->data << " "; preorder(n->left); preorder(n->right); }
//     void inorder(Node* n) { if (!n) return; inorder(n->left); cout << n->data << " "; inorder(n->right); }
//     void postorder(Node* n) { if (!n) return; postorder(n->left); postorder(n->right); cout << n->data << " "; }

//     void levelOrder() {
//         if (!root) return;
//         queue<Node*> q; q.push(root);
//         while (!q.empty()) {
//             Node* c = q.front(); q.pop();
//             cout << c->data << " ";
//             if (c->left) q.push(c->left);
//             if (c->right) q.push(c->right);
//         }
//     }

//     bool search(Node* n, int v) {
//         if (!n) return false;
//         if (n->data == v) return true;
//         return search(n->left, v) || search(n->right, v);
//     }

//     int countNodes(Node* n) {
//         if (!n) return 0;
//         return 1 + countNodes(n->left) + countNodes(n->right);
//     }

//     int countLeaf(Node* n) {
//         if (!n) return 0;
//         if (!n->left && !n->right) return 1;
//         return countLeaf(n->left) + countLeaf(n->right);
//     }

//     int countInternal(Node* n) {
//         if (!n || (!n->left && !n->right)) return 0;
//         return 1 + countInternal(n->left) + countInternal(n->right);
//     }

//     int height(Node* n) {
//         if (!n) return -1;
//         return 1 + max(height(n->left), height(n->right));
//     }

//     void countEvenOdd(Node* n, int &e, int &o) {
//         if (!n) return;
//         (n->data % 2 == 0) ? e++ : o++;
//         countEvenOdd(n->left, e, o);
//         countEvenOdd(n->right, e, o);
//     }

//     int sum(Node* n) {
//         if (!n) return 0;
//         return n->data + sum(n->left) + sum(n->right);
//     }

//     int maxVal(Node* n) {
//         if (!n) return INT_MIN;
//         return max(n->data, max(maxVal(n->left), maxVal(n->right)));
//     }

//     int minVal(Node* n) {
//         if (!n) return INT_MAX;
//         return min(n->data, min(minVal(n->left), minVal(n->right)));
//     }

//     void mirror(Node* n) {
//         if (!n) return;
//         swap(n->left, n->right);
//         mirror(n->left);
//         mirror(n->right);
//     }

//     Node* findParent(Node* n, int v, Node* p = nullptr) {
//         if (!n) return nullptr;
//         if (n->data == v) return p;
//         Node* l = findParent(n->left, v, n);
//         if (l) return l;
//         return findParent(n->right, v, n);
//     }

//     Node* copyTree(Node* n) {
//         if (!n) return nullptr;
//         Node* x = new Node(n->data);
//         x->left = copyTree(n->left);
//         x->right = copyTree(n->right);
//         return x;
//     }

//     Node* merge(Node* a, Node* b) {
//         if (!a) return b;
//         if (!b) return a;
//         Node* m = new Node(a->data + b->data);
//         m->left = merge(a->left, b->left);
//         m->right = merge(a->right, b->right);
//         return m;
//     }

//     BinaryTree mergeTrees(BinaryTree &t2) {
//         BinaryTree result;
//         result.root = merge(this->root, t2.root);
//         cout << "Trees merged successfully.\n";
//         return result;
//     }

//     pair<BinaryTree, BinaryTree> splitTree() {
//         BinaryTree leftTree, rightTree;
//         if (!root) return { leftTree, rightTree };
//         leftTree.root = copyTree(root->left);
//         rightTree.root = copyTree(root->right);
//         cout << "Tree split into left and right subtrees.\n";
//         return { leftTree, rightTree };
//     }

//     bool isBST(Node* n, int mn = INT_MIN, int mx = INT_MAX) {
//         if (!n) return true;
//         if (n->data <= mn || n->data >= mx) return false;
//         return isBST(n->left, mn, n->data) && isBST(n->right, n->data, mx);
//     }

//     bool isPerfect(Node* n) {
//         int h = height(n);
//         return countNodes(n) == pow(2, h + 1) - 1;
//     }

//     bool isComplete(Node* r) {
//         if (!r) return true;
//         queue<Node*> q;
//         q.push(r);
//         bool gap = false;
//         while (!q.empty()) {
//             Node* c = q.front(); q.pop();
//             if (!c) gap = true;
//             else {
//                 if (gap) return false;
//                 q.push(c->left);
//                 q.push(c->right);
//             }
//         }
//         return true;
//     }

//     int depth(Node* n, int v, int d = 0) {
//         if (!n) return -1;
//         if (n->data == v) return d;
//         int l = depth(n->left, v, d + 1);
//         if (l != -1) return l;
//         return depth(n->right, v, d + 1);
//     }

//     Node* LCA(Node* n, int a, int b) {
//         if (!n) return nullptr;
//         if (n->data == a || n->data == b) return n;
//         Node* l = LCA(n->left, a, b);
//         Node* r = LCA(n->right, a, b);
//         if (l && r) return n;
//         return l ? l : r;
//     }

//     bool path(Node* n, int v, vector<int>& p) {
//         if (!n) return false;
//         p.push_back(n->data);
//         if (n->data == v) return true;
//         if (path(n->left, v, p) || path(n->right, v, p)) return true;
//         p.pop_back();
//         return false;
//     }

//     void show(Node* n) {
//         if (!n) return;
//         if (n->left) cout << n->data << " -> L: " << n->left->data << endl;
//         if (n->right) cout << n->data << " -> R: " << n->right->data << endl;
//         show(n->left);
//         show(n->right);
//     }

//     void clear(Node* n) {
//         if (!n) return;
//         clear(n->left);
//         clear(n->right);
//         delete n;
//     }

//     void clearTree() {
//         clear(root);
//         root = nullptr;
//         cout << "Tree cleared.\n";
//     }
// };

// int main() {
//     BinaryTree t1;
//     t1.insert(10);
//     t1.insert(5);
//     t1.insert(15);
//     t1.insert(3);
//     t1.insert(7);
//     t1.insert(12);
//     t1.insert(18);

//     cout << "\nInorder: ";
//     t1.inorder(t1.getRoot());
//     cout << endl;

//     cout << "Nodes: " << t1.countNodes(t1.getRoot()) << "  Height: " << t1.height(t1.getRoot()) << endl;

//     auto [leftTree, rightTree] = t1.splitTree();
//     cout << "\nLeft Subtree (Inorder): ";
//     leftTree.inorder(leftTree.getRoot());
//     cout << "\nRight Subtree (Inorder): ";
//     rightTree.inorder(rightTree.getRoot());
//     cout << endl;

//     BinaryTree mergedTree = leftTree.mergeTrees(rightTree);
//     cout << "\nMerged Tree (Inorder): ";
//     mergedTree.inorder(mergedTree.getRoot());
//     cout << endl;

//     cout << "\nMirror of Merged Tree (Inorder): ";
//     mergedTree.mirror(mergedTree.g