#include <iostream>
#include <cmath>
#include <climits>
using namespace std;

class BinaryTree {
private:
    int *data;
    bool *status;
    int height;
    int size;

public:
   
    BinaryTree(int h) {
        height = h;
        size = pow(2, height + 1) - 1;
        data = new int[size];
        status = new bool[size];
        for (int i = 0; i < size; i++) status[i] = false;
    }

   
    ~BinaryTree() {
        delete[] data;
        delete[] status;
    }

  
    void setRoot(int v) {
        if (!status[0]) {
            data[0] = v;
            status[0] = true;
            cout << "Root created with value " << v << endl;
        } else cout << "Root already exists!\n";
    }

    
    void setLeftNode(int i, int v) {
        int left = 2 * i + 1;
        if (i >= size || !status[i]) {
            cout << "Parent does not exist.\n";
            return;
        }
        if (left < size && !status[left]) {
            data[left] = v;
            status[left] = true;
            cout << "Left node created at index " << left << " with value " << v << endl;
        } else cout << "Left node cannot be created.\n";
    }

   
    void setRightNode(int i, int v) {
        int right = 2 * i + 2;
        if (i >= size || !status[i]) {
            cout << "Parent does not exist.\n";
            return;
        }
        if (right < size && !status[right]) {
            data[right] = v;
            status[right] = true;
            cout << "Right node created at index " << right << " with value " << v << endl;
        } else cout << "Right node cannot be created.\n";
    }

    void removeNode(int i) {
        if (i >= size || !status[i]) return;
        removeNode(2 * i + 1);
        removeNode(2 * i + 2);
        status[i] = false;
        cout << "Removed node at index " << i << endl;
    }

   
    int search(int val) {
        for (int i = 0; i < size; i++)
            if (status[i] && data[i] == val)
                return i;
        return -1;
    }

    void display() {
        cout << "\nTree Nodes (Index : Value)\n";
        for (int i = 0; i < size; i++)
            if (status[i])
                cout << i << " : " << data[i] << endl;
    }

   
    void preorder(int i = 0) {
        if (i >= size || !status[i]) return;
        cout << data[i] << " ";
        preorder(2 * i + 1);
        preorder(2 * i + 2);
    }

    void inorder(int i = 0) {
        if (i >= size || !status[i]) return;
        inorder(2 * i + 1);
        cout << data[i] << " ";
        inorder(2 * i + 2);
    }

    void postorder(int i = 0) {
        if (i >= size || !status[i]) return;
        postorder(2 * i + 1);
        postorder(2 * i + 2);
        cout << data[i] << " ";
    }

    
    int countNodes() {
        int c = 0;
        for (int i = 0; i < size; i++) if (status[i]) c++;
        return c;
    }

    int countLeafNodes() {
        int count = 0;
        for (int i = 0; i < size; i++)
            if (status[i]) {
                int l = 2 * i + 1, r = 2 * i + 2;
                if ((l >= size || !status[l]) && (r >= size || !status[r])) count++;
            }
        return count;
    }

    int countInternalNodes() {
        return countNodes() - countLeafNodes();
    }

    
    int countEven() {
        int c = 0;
        for (int i = 0; i < size; i++)
            if (status[i] && data[i] % 2 == 0) c++;
        return c;
    }

    int countOdd() {
        int c = 0;
        for (int i = 0; i < size; i++)
            if (status[i] && data[i] % 2 != 0) c++;
        return c;
    }

    
    int levelWithMaxSum() {
        int maxSum = INT_MIN, bestLevel = -1;
        int totalLevels = heightOfTree() + 1;
        for (int lvl = 0; lvl < totalLevels; lvl++) {
            int start = pow(2, lvl) - 1;
            int end = min(size - 1, (int)pow(2, lvl + 1) - 2);
            int sum = 0;
            for (int i = start; i <= end; i++)
                if (status[i]) sum += data[i];
            if (sum > maxSum) { maxSum = sum; bestLevel = lvl; }
        }
        return bestLevel;
    }

  
    void printLeafNodes() {
        cout << "Leaf nodes: ";
        for (int i = 0; i < size; i++) {
            if (status[i]) {
                int l = 2 * i + 1, r = 2 * i + 2;
                if ((l >= size || !status[l]) && (r >= size || !status[r]))
                    cout << data[i] << " ";
            }
        }
        cout << endl;
    }

 
    bool isBST(int i = 0, int minVal = INT_MIN, int maxVal = INT_MAX) {
        if (i >= size || !status[i]) return true;
        if (data[i] <= minVal || data[i] >= maxVal) return false;
        return isBST(2 * i + 1, minVal, data[i]) &&
               isBST(2 * i + 2, data[i], maxVal);
    }

    
    int countEmptySlots() {
        int c = 0;
        for (int i = 0; i < size; i++)
            if (!status[i]) c++;
        return c;
    }

    void showRelations(int i) {
        if (i >= size || !status[i]) return;
        int p = (i - 1) / 2, l = 2 * i + 1, r = 2 * i + 2;
        cout << "\nRelations for " << data[i] << ":\n";
        cout << "Parent: " << ((i == 0) ? -1 : data[p]) << endl;
        if (l < size && status[l]) cout << "Left child: " << data[l] << endl;
        else cout << "Left child: None\n";
        if (r < size && status[r]) cout << "Right child: " << data[r] << endl;
        else cout << "Right child: None\n";
    }

   
    void mirror(int i = 0) {
        if (i >= size || !status[i]) return;
        int l = 2 * i + 1, r = 2 * i + 2;
        if (l < size && r < size) {
            swap(data[l], data[r]);
            swap(status[l], status[r]);
        }
        mirror(l);
        mirror(r);
    }

  
    int sumOfNodes() {
        int sum = 0;
        for (int i = 0; i < size; i++) if (status[i]) sum += data[i];
        return sum;
    }

    int maxValue() {
        int m = INT_MIN;
        for (int i = 0; i < size; i++) if (status[i]) m = max(m, data[i]);
        return m;
    }

    int minValue() {
        int m = INT_MAX;
        for (int i = 0; i < size; i++) if (status[i]) m = min(m, data[i]);
        return m;
    }

   
    void mergeTrees(BinaryTree &t2) {
        int minSize = min(size, t2.size);
        for (int i = 0; i < minSize; i++) {
            if (t2.status[i]) {
                data[i] = t2.data[i];
                status[i] = true;
            }
        }
        cout << "Trees merged successfully!\n";
    }

    
    void copySubtree(int srcIndex, BinaryTree &dest, int destIndex) {
        if (srcIndex >= size || !status[srcIndex] || destIndex >= dest.size)
            return;
        dest.data[destIndex] = data[srcIndex];
        dest.status[destIndex] = true;
        copySubtree(2 * srcIndex + 1, dest, 2 * destIndex + 1);
        copySubtree(2 * srcIndex + 2, dest, 2 * destIndex + 2);
    }

    
    BinaryTree splitTree(bool leftSubtree = true) {
        BinaryTree sub(height - 1);
        int root = leftSubtree ? 1 : 2;
        copySubtree(root, sub, 0);
        cout << (leftSubtree ? "Left" : "Right") << " subtree created!\n";
        return sub;
    }

    bool isEmpty() {
        return !status[0];
    }

    bool isFull() {
        for (int i = 0; i < size; i++)
            if (status[i]) {
                int l = 2 * i + 1, r = 2 * i + 2;
                if ((l < size && status[l]) != (r < size && status[r])) return false;
            }
        return true;
    }

    bool isComplete() {
        bool gap = false;
        for (int i = 0; i < size; i++) {
            if (!status[i]) gap = true;
            else if (gap) return false;
        }
        return true;
    }

    bool isPerfect() {
        int h = heightOfTree();
        return countNodes() == pow(2, h + 1) - 1;
    }

    int heightOfTree() {
        int lastIndex = -1;
        for (int i = size - 1; i >= 0; i--)
            if (status[i]) { lastIndex = i; break; }
        if (lastIndex == -1) return -1;
        return floor(log2(lastIndex + 1));
    }

    int depthOfNode(int i) {
        if (i >= size || !status[i]) return -1;
        return floor(log2(i + 1));
    }

  
    void copyTree(BinaryTree &src) {
        int minSize = min(size, src.size);
        for (int i = 0; i < minSize; i++) {
            data[i] = src.data[i];
            status[i] = src.status[i];
        }
    }

    bool isEqual(BinaryTree &t2) {
        if (size != t2.size) return false;
        for (int i = 0; i < size; i++)
            if (status[i] != t2.status[i] || (status[i] && data[i] != t2.data[i]))
                return false;
        return true;
    }

    void clear() {
        for (int i = 0; i < size; i++) status[i] = false;
        cout << "Tree cleared!\n";
    }

    int countGreaterThan(int x) {
        int count = 0;
        for (int i = 0; i < size; i++) if (status[i] && data[i] > x) count++;
        return count;
    }

    void findPathToValue(int value, int i = 0, string path = "Root") {
        if (i >= size || !status[i]) return;
        if (data[i] == value) {
            cout << "Path to " << value << ": " << path << endl;
            return;
        }
        findPathToValue(value, 2 * i + 1, path + " -> Left");
        findPathToValue(value, 2 * i + 2, path + " -> Right");
    }
};

int main() {
    BinaryTree t1(3);


    t1.setRoot(10);
    t1.setLeftNode(0, 5);
    t1.setRightNode(0, 15);
    t1.setLeftNode(1, 3);
    t1.setRightNode(1, 7);
    t1.setLeftNode(2, 12);
    t1.setRightNode(2, 18);

    t1.display();

    cout << "\nHeight of tree: " << t1.heightOfTree();
    cout << "\nTree is " << (t1.isFull() ? "Full" : "Not Full");
    cout << "\nTree is " << (t1.isComplete() ? "Complete" : "Not Complete");
    cout << "\nTree is " << (t1.isPerfect() ? "Perfect" : "Not Perfect") << endl;

    cout << "\nNodes greater than 8: " << t1.countGreaterThan(8) << endl;

    t1.findPathToValue(7);
    cout << "\nSum = " << t1.sumOfNodes() << " | Max = " << t1.maxValue() << " | Min = " << t1.minValue() << endl;

    cout << "\nSplitting Right Subtree:\n";
    BinaryTree rightT = t1.splitTree(false);
    rightT.display();

    cout << "\nMerging Subtree Back:\n";
    t1.mergeTrees(rightT);
    t1.display();

    cout << "\nMirroring Tree:\n";
    t1.mirror();
    t1.display();

    cout << "\nClearing Tree...\n";
    t1.clear();
    t1.display();

    return 0;
}